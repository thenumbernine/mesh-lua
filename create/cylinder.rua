#!/usr/bin/env rua
-- create a cylinder with 'r' sides, writes it to fn
local vec3f = require 'vec-ffi.vec3f'
local Mesh = require 'mesh'
local fn, r = ...
assert(fn, "expected filename")
r = tonumber(r) or 8
local uvs = {{0,0}, {1,0}, {1,1}, {0,1}}
local tris = {0, 1, 2, 2, 3, 0}
local oppotris = table(tris):reverse()
local m = Mesh()
local texcoordWidth = 1/16
local texcoordHeight = 1/16
-- top and bottom
for pm=0,1 do

	-- center for evenness of tris
	local v = m.vtxs:emplace_back()
	v.pos:set(0, 0, pm * 2 - 1)
	v.texcoord:set(
		texcoordWidth * .5,
		(1-pm) * 2 * texcoordHeight + texcoordHeight * .5,
		0
	)
	v.normal:set(0, 0, pm * 2 - 1)

	local vbase = #m.vtxs
	for i=0,r do
		local theta = 2 * math.pi * i / r
		local costh, sinth = math.cos(theta), math.sin(theta)
		local v = m.vtxs:emplace_back()
		v.pos:set(costh, sinth, pm * 2 - 1)
		-- do we want top and bottom same texcoords or different?
		-- probably different
		v.texcoord:set(
			-- top gets [0,1/16]^2
			-- bottom gets [0,1/16] x [2/16,3/16]
			texcoordWidth * (costh * .5 + .5),
			(1-pm) * 2 * texcoordHeight + texcoordHeight * (sinth * .5 + .5),
			0
		)
		v.normal:set(0, 0, pm * 2 - 1)
		if i < r then
			if pm == 0 then
				m.triIndexes:push_back(vbase - 1)
				m.triIndexes:push_back(vbase + r - i)
				m.triIndexes:push_back(vbase + r - ((i + 1)))
			else
				m.triIndexes:push_back(vbase - 1)
				m.triIndexes:push_back(vbase + i)
				m.triIndexes:push_back(vbase + (i + 1))
			end
		end
	end
end
-- sides
-- new vtxs for different texcoords?
local vbase = #m.vtxs
for i=0,r do
	local theta = 2 * math.pi * i / r
	local costh, sinth = math.cos(theta), math.sin(theta)
	for pm=0,1 do
		local v = m.vtxs:emplace_back()
		v.pos:set(costh, sinth, pm * 2 - 1)
		v.texcoord:set(texcoordWidth * i/r, texcoordHeight + texcoordHeight * pm, 0)
		v.normal:set(costh, sinth, 0)
	end
	if i < r then
		local a = 2 * i + 2
		local b = 2 * i + 3
		local d = 2 * i + 0
		local c = 2 * i + 1
		m.triIndexes:push_back(vbase + a)
		m.triIndexes:push_back(vbase + b)
		m.triIndexes:push_back(vbase + c)
		m.triIndexes:push_back(vbase + c)
		m.triIndexes:push_back(vbase + d)
		m.triIndexes:push_back(vbase + a)
	end
end
m:rebuildTris()
m.mtlFilenames = table{'hue.mtl'}
m.groups:insert{
	name = 'm',
	triFirstIndex = 0,
	triCount = #m.tris,
}
m:assertGroups()
require 'mesh.objloader'():save(fn, m)

